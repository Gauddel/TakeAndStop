{
  "language": "Solidity",
  "sources": {
    "contracts/ConditionCompareAssetPriceForStopLoss.sol": {
      "content": "pragma solidity ^0.6.2;\n\nimport { GelatoConditionsStandard } from \"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\";\nimport { SafeMath } from \"@gelatonetwork/core/contracts/external/SafeMath.sol\";\nimport { GelatoBytes } from \"./GelatoBytes.sol\";\n\ncontract ConditionCompareAssetPriceForStopLoss is GelatoConditionsStandard {\n\n    using GelatoBytes for bytes;\n\n    function getConditionData( address _source, bytes calldata  _sourceData, uint _limit)\n        public\n        pure\n        virtual\n        returns (bytes memory)\n    {\n        return abi.encode(_source, _sourceData, _limit);\n    }\n    function ok(uint256, bytes calldata _conditionData, uint256)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        (address source,\n         bytes memory sourceData,\n         uint limit) = abi.decode(\n            _conditionData,\n            (address,bytes,uint)\n        );\n\n        return stopLoss(source, sourceData, limit);\n    }\n\n    function stopLoss(address _source, bytes memory _sourceData, uint limit)\n        internal\n        view\n        returns(string memory)\n    {\n        (bool success, bytes memory returndata) = _source.staticcall(_sourceData);\n        if(!success) {\n            return returndata.generateErrorString(\n                \"ConditionCompareAssetPrice.stopLoss._source:\"\n            );\n        }\n\n        uint price = abi.decode(returndata, (uint));\n\n        if (price <= limit) return OK;\n        return \"NotOKPriceStillGreaterThanTheStopLossLimit\";\n    }\n}"
    },
    "@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\n\nimport \"./IGelatoCondition.sol\";\n\nabstract contract GelatoConditionsStandard is IGelatoCondition {\n    string internal constant OK = \"OK\";\n}\n"
    },
    "@gelatonetwork/core/contracts/conditions/IGelatoCondition.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\n/// @notice all the APIs of GelatoConditionsStandard\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\ninterface IGelatoCondition {\n\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\n    ///  \"ok\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\n    ///  source of Task identification.\n    /// @param _conditionData This is the Condition.data field developers must encode their\n    ///  Condition's specific parameters in.\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\n        external\n        view\n        returns(string memory);\n}"
    },
    "@gelatonetwork/core/contracts/external/SafeMath.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/GelatoBytes.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity 0.6.12;\n\nlibrary GelatoBytes {\n    function calldataSliceSelector(bytes calldata _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function memorySliceSelector(bytes memory _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function revertWithErrorString(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly { selector := mload(add(0x20, _bytes)) }\n            if (selector == 0x08c379a0) {  // Function selector for Error(string)\n                assembly { _bytes := add(_bytes, 68) }\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\n            } else {\n                revert(string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\")));\n            }\n        } else {\n            revert(string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\")));\n        }\n    }\n\n    function generateErrorString(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n        returns (string memory)\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly { selector := mload(add(0x20, _bytes)) }\n            if (selector == 0x08c379a0) {  // Function selector for Error(string)\n                assembly { _bytes := add(_bytes, 68) }\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\n            } else {\n                return string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"));\n            }\n        } else {\n            return string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"));\n        }\n    }\n}"
    },
    "contracts/ConditionCompareAssetPriceForTakeProfit.sol": {
      "content": "pragma solidity ^0.6.2;\n\nimport { GelatoConditionsStandard } from \"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\";\nimport { SafeMath } from \"@gelatonetwork/core/contracts/external/SafeMath.sol\";\nimport { GelatoBytes } from \"./GelatoBytes.sol\";\n\ncontract ConditionCompareAssetPriceForTakeProfit is GelatoConditionsStandard {\n\n    using GelatoBytes for bytes;\n\n    function getConditionData( address _source, bytes calldata  _sourceData, int _limit)\n        public\n        pure\n        virtual\n        returns (bytes memory)\n    {\n        return abi.encode(_source, _sourceData, _limit);\n    }\n    function ok(uint256, bytes calldata _conditionData, uint256)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        (address source,\n         bytes memory sourceData,\n         int limit) = abi.decode(\n            _conditionData,\n            (address,bytes,int)\n        );\n\n        return takeProfit(source, sourceData, limit);\n    }\n\n    function takeProfit(address _source, bytes memory _sourceData, int limit)\n        internal\n        view\n        returns(string memory)\n    {\n        (bool success, bytes memory returndata) = _source.staticcall(_sourceData);\n        if(!success) {\n            return returndata.generateErrorString(\n                \"ConditionCompareAssetPrice.takeProfit._source:\"\n            );\n        }\n\n        int price = abi.decode(returndata, (int));\n\n        if (price >= limit) return OK;\n        return \"NotOKPriceStillLesserThanTheTakeProfitLimit\";\n    }\n}"
    },
    "contracts/DSMath.sol": {
      "content": "\npragma solidity ^0.6.2;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}"
    },
    "contracts/Extensions.sol": {
      "content": "pragma solidity ^0.6.2;\n\ncontract Extensions {\n    function convertIntToUint(int a) internal pure returns(uint) {\n        if (a >= 0) {\n            return uint(a);\n        }\n        return uint(a * -1);\n    }\n}"
    },
    "contracts/IPriceFeed.sol": {
      "content": "pragma solidity ^0.6.2;\n\ninterface IPriceFeed {\n    function getLatestPriceToken0() external view virtual returns (uint);\n\n    function getLatestPriceToken1() external view virtual returns (uint);\n}"
    },
    "contracts/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.6.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/Mocks/PriceFeedMock.sol": {
      "content": "pragma solidity ^0.6.2;\n\nimport \"./../IPriceFeed.sol\";\n\ncontract PriceFeedMock {\n\n    IPriceFeed internal priceFeed;\n    bool internal mockMode;\n    uint internal price;\n\n    constructor(address _priceFeed) public {\n        priceFeed = IPriceFeed(_priceFeed);\n        mockMode = false;\n    }\n\n    function mock(uint _newPrice) public {\n        mockMode = true;\n        price = _newPrice;\n    }\n\n    function getLatestPriceToken0() public view returns (uint) {\n        if (mockMode) {\n            return price;\n        }\n        return priceFeed.getLatestPriceToken0();\n    }\n\n    function getLatestPriceToken1() public view returns (uint) {\n        if (mockMode) {\n            return price;\n        }\n        return priceFeed.getLatestPriceToken1();\n    }\n}"
    },
    "contracts/PriceFeedDAIETH.sol": {
      "content": "pragma solidity ^0.6.2;\n\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport \"./DSMath.sol\";\nimport \"./Extensions.sol\";\nimport \"./IPriceFeed.sol\";\n\ncontract PriceFeedDAIETH is IPriceFeed, DSMath, Extensions {\n    AggregatorV3Interface internal priceFeed;\n\n    constructor() public {\n        priceFeed = AggregatorV3Interface(0x773616E4d11A78F511299002da57A0a94577F1f4);\n    }\n\n    function getLatestPriceToken0() public view override returns (uint) {\n        (\n            uint80 roundID, \n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        require(timeStamp > 0, \"Round not complete\");\n        return convertIntToUint(price);\n    }\n\n    function getLatestPriceToken1() public view override returns (uint) { // Use Wad  for DAI/ETH\n        return wdiv(1 ether, getLatestPriceToken0());\n    }\n}"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "pragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/PriceFeedETHUSD.sol": {
      "content": "pragma solidity ^0.6.2;\n\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport \"./DSMath.sol\";\nimport \"./Extensions.sol\";\nimport \"./IPriceFeed.sol\";\n\ncontract PriceFeedETHUSD is IPriceFeed, DSMath, Extensions {\n    AggregatorV3Interface internal priceFeed;\n\n    constructor() public {\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    }\n\n    function getLatestPriceToken0() public view override returns (uint) {\n        (\n            uint80 roundID, \n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        require(timeStamp > 0, \"Round not complete\");\n        return mul(convertIntToUint(price), 10 ** 10); // Transform to wad\n    }\n\n    function getLatestPriceToken1() public view override returns (uint) { // Use Wad  for ETH/USD\n        return wdiv(1 ether, getLatestPriceToken0());\n    }\n}"
    },
    "contracts/ProviderModuleDSA.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    GelatoProviderModuleStandard\n} from \"@gelatonetwork/core/contracts/provider_modules/GelatoProviderModuleStandard.sol\";\nimport {Task} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\n\n/// @dev InstaDapp Index\ninterface IndexInterface {\n    function connectors(uint version) external view returns (address);\n    function list() external view returns (address);\n}\n\n/// @dev InstaDapp List\ninterface ListInterface {\n    function accountID(address _account) external view returns (uint64);\n}\n\n/// @dev InstaDapp Connectors\ninterface ConnectorsInterface {\n    function isConnector(address[] calldata logicAddr) external view returns (bool);\n    function isStaticConnector(address[] calldata logicAddr) external view returns (bool);\n}\n\n/// @dev InstaDapp Defi Smart Account wallet\ninterface AccountInterface {\n    function version() external view returns (uint);\n    function isAuth(address user) external view returns (bool);\n    function shield() external view returns (bool);\n    function cast(address[] calldata _targets, bytes[] calldata _datas, address _origin)\n        external\n        payable\n        returns (bytes32[] memory responses);\n}\n\ncontract ProviderModuleDSA is GelatoProviderModuleStandard {\n    IndexInterface public immutable index;\n    address public immutable gelatoCore;\n\n    constructor(IndexInterface _index, address _gelatoCore) public {\n        index = _index;\n        gelatoCore = _gelatoCore;\n    }\n\n    // ================= GELATO PROVIDER MODULE STANDARD ================\n    function isProvided(address _userProxy, address, Task calldata _task)\n        external\n        view\n        override\n        returns(string memory)\n    {\n        // Verify InstaDapp account identity\n        if (ListInterface(index.list()).accountID(_userProxy) == 0)\n            return \"ProviderModuleDSA.isProvided:InvalidUserProxy\";\n\n        // Is GelatoCore authorized\n        if (!AccountInterface(_userProxy).isAuth(gelatoCore))\n            return \"ProviderModuleDSA.isProvided:GelatoCoreNotAuth\";\n\n        // @dev commented out for gas savings\n\n        // // Is connector valid\n        // ConnectorsInterface connectors = ConnectorsInterface(index.connectors(\n        //     AccountInterface(_userProxy).version()\n        // ));\n\n        // address[] memory targets = new address[](_task.actions.length);\n        // for (uint i = 0; i < _task.actions.length; i++)\n        //     targets[i] = _task.actions[i].addr;\n\n        // bool isShield = AccountInterface(_userProxy).shield();\n        // if (isShield)\n        //     if (!connectors.isStaticConnector(targets))\n        //         return \"ProviderModuleDSA.isProvided:not-static-connector\";\n        // else\n        //     if (!connectors.isConnector(targets))\n        //         return \"ProviderModuleDSA.isProvided:not-connector\";\n\n        return OK;\n    }\n\n    /// @dev DS PROXY ONLY ALLOWS DELEGATE CALL for single actions, that's why we also use multisend\n    function execPayload(uint256, address, address, Task calldata _task, uint256)\n        external\n        view\n        override\n        returns(bytes memory payload, bool)\n    {\n        address[] memory targets = new address[](_task.actions.length);\n        for (uint i = 0; i < _task.actions.length; i++)\n            targets[i] = _task.actions[i].addr;\n\n        bytes[] memory datas = new bytes[](_task.actions.length);\n        for (uint i = 0; i < _task.actions.length; i++)\n            datas[i] = _task.actions[i].data;\n\n        payload = abi.encodeWithSelector(\n            AccountInterface.cast.selector,\n            targets,\n            datas,\n            gelatoCore\n        );\n    }\n}"
    },
    "@gelatonetwork/core/contracts/provider_modules/GelatoProviderModuleStandard.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {IGelatoProviderModule} from \"./IGelatoProviderModule.sol\";\nimport {Task} from \"../gelato_core/interfaces/IGelatoCore.sol\";\n\nabstract contract GelatoProviderModuleStandard is IGelatoProviderModule {\n\n    string internal constant OK = \"OK\";\n\n    function isProvided(address, address, Task calldata)\n        external\n        view\n        virtual\n        override\n        returns(string memory)\n    {\n        return OK;\n    }\n\n    function execPayload(uint256, address, address, Task calldata, uint256)\n        external\n        view\n        virtual\n        override\n        returns(bytes memory payload, bool)\n    {\n        return (payload, false);\n    }\n\n    /// @dev Overriding fns should revert with the revertMsg they detected on the userProxy\n    function execRevertCheck(bytes calldata) external pure override virtual {\n        // By default no reverts detected => do nothing\n    }\n}\n"
    },
    "@gelatonetwork/core/contracts/provider_modules/IGelatoProviderModule.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {Action, Task} from \"../gelato_core/interfaces/IGelatoCore.sol\";\n\ninterface IGelatoProviderModule {\n\n    /// @notice Check if provider agrees to pay for inputted task receipt\n    /// @dev Enables arbitrary checks by provider\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @return \"OK\" if provider agrees\n    function isProvided(address _userProxy, address _provider, Task calldata _task)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Convert action specific payload into proxy specific payload\n    /// @dev Encoded multiple actions into a multisend\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\n    /// @return Encoded payload that will be used for low-level .call on user proxy\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\n    function execPayload(\n        uint256 _taskReceiptId,\n        address _userProxy,\n        address _provider,\n        Task calldata _task,\n        uint256 _cycleId\n    )\n        external\n        view\n        returns(bytes memory, bool checkReturndata);\n\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {IGelatoProviderModule} from \"../../provider_modules/IGelatoProviderModule.sol\";\nimport {IGelatoCondition} from \"../../conditions/IGelatoCondition.sol\";\n\nstruct Provider {\n    address addr;  //  if msg.sender == provider => self-Provider\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\n}\n\nstruct Condition {\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\n    bytes data;  // can be bytes32(0) for self-conditional Actions\n}\n\nenum Operation { Call, Delegatecall }\n\nenum DataFlow { None, In, Out, InAndOut }\n\nstruct Action {\n    address addr;\n    bytes data;\n    Operation operation;\n    DataFlow dataFlow;\n    uint256 value;\n    bool termsOkCheck;\n}\n\nstruct Task {\n    Condition[] conditions;  // optional\n    Action[] actions;\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\n}\n\nstruct TaskReceipt {\n    uint256 id;\n    address userProxy;\n    Provider provider;\n    uint256 index;\n    Task[] tasks;\n    uint256 expiryDate;\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\n    uint256 submissionsLeft;\n}\n\ninterface IGelatoCore {\n    event LogTaskSubmitted(\n        uint256 indexed taskReceiptId,\n        bytes32 indexed taskReceiptHash,\n        TaskReceipt taskReceipt\n    );\n\n    event LogExecSuccess(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorSuccessFee,\n        uint256 sysAdminSuccessFee\n    );\n    event LogCanExecFailed(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        string reason\n    );\n    event LogExecReverted(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorRefund,\n        string reason\n    );\n\n    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\n\n    /// @notice API to query whether Task can be submitted successfully.\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _userProxy The userProxy from which the task will be submitted.\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\n    function canSubmitTask(\n        address _userProxy,\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    )\n        external\n        view\n        returns(string memory);\n\n    /// @notice API to submit a single Task.\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _task A Gelato Task object: provider, conditions, actions.\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\n    function submitTask(\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    )\n        external;\n\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _cycles How many full cycles will be submitted\n    function submitTaskCycle(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _cycles\n    )\n        external;\n\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\n    ///  would be submitted, but not the second\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\n    ///  that should have occured once the cycle is complete:\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\n    ///  ...\n    function submitTaskChain(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _sumOfRequestedTaskSubmits\n    )\n        external;\n\n    // ================  Exec Suite =========================\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\n    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\n    ///   In the latter case Executors are refunded by the Task Provider.\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function exec(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel task\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function cancelTask(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel multiple tasks at once\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\n\n    /// @notice Compute hash of task receipt\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @return hash of taskReceipt\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\n\n    // ================  Getters =========================\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\n    /// @return currentId currentId, last TaskReceiptId submitted\n    function currentTaskReceiptId() external view returns(uint256);\n\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\n    /// @return hash of taskReceipt\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\n}\n"
    },
    "contracts/WETH.sol": {
      "content": "pragma solidity ^0.6.2;\n\ncontract WETH9 {\n    function deposit() public payable {\n    }\n    function withdraw(uint wad) public {\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        return true;\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}